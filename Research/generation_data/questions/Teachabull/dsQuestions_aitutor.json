{
    "questions": [
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Imagine you are implementing a graph data structure to represent a simplified map of a network. Define a `Graph` class that uses an adjacency list to store nodes and edges. Implement methods for adding nodes (add_node) and edges (add_edge), and a method for performing Breadth-First Search (BFS) from a given start node. Demonstrate your implementation by creating a small graph and performing a BFS.",
                "boilerplate": "class Graph:\n\tdef __init__(self):\n\t\t# Your code here\n\n\tdef add_node(self, value):\n\t\t# Your code here\n\n\tdef add_edge(self, from_node, to_node):\n\t\t# Your code here\n\n\tdef bfs(self, start_node):\n\t\t# Your code here\n\n# Example usage\n# Create a graph instance\n# Add nodes and edges\n# Perform BFS",
                "test_cases_script": "def test_bfs(graph):\n\t# Your test cases here\n\tassert graph.bfs(start_node) == expected_output,\n\t'Failed test: BFS did not find the nodes in the expected order'",
                "concepts": [
                    "Graph Data Structure",
                    "nodes",
                    "edges",
                    "adjacency list",
                    "Graph Traversal Algorithms"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Implement two separate functions in Python: one for Breadth-First Search (BFS) and another for Dijkstra's algorithm on an unweighted graph represented as an adjacency list. Compare the time complexity of both algorithms, and comment on why Dijkstra's algorithm might still be preferred in certain scenarios despite BFS being more optimal for unweighted graphs.",
                "boilerplate": "def bfs(graph, start_vertex):\n    pass  # TODO: Implement BFS\n\ndef dijkstras(graph, start_vertex):\n    pass  # TODO: Implement Dijkstra's Algorithm\n\n# Compare the time complexity of BFS and Dijkstra's algorithm and comment on the preference of Dijkstra's in certain scenarios.",
                "test_cases_script": "",
                "concepts": [
                    "Graph Data Structure",
                    "Graph Pathfinding Algorithms",
                    "Dijkstra's algorithm",
                    "Breadth-First Search (BFS)",
                    "time complexity",
                    "Optimizations"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Implement the A* pathfinding algorithm to determine the shortest path between two nodes in a graph. You are provided with the following graph representation (as an adjacency list), the heuristic function 'h', and the start and end node identifiers. Complete the A* algorithm to return the shortest path from start to end.",
                "boilerplate": "def a_star_algorithm(graph, start, end, h):\n\t# TODO: Implement the A* Algorithm here\n\tpass",
                "test_cases_script": "G = {\n  'A': {'B': 1, 'C': 3},\n  'B': {'A': 1, 'D': 7, 'E': 5},\n  'C': {'A': 3, 'F': 4},\n  'D': {'B': 7, 'F': 1},\n  'E': {'B': 5, 'F': 6},\n  'F': {'C': 4, 'D': 1, 'E': 6}\n}\nh = {'A': 7, 'B': 2, 'C': 6, 'D': 3, 'E': 1, 'F': 0}\n\nassert a_star_algorithm(G, 'A', 'F', h) == ['A', 'C', 'F']",
                "concepts": [
                    "Graph Pathfinding Algorithms",
                    "cost functions",
                    "heuristics",
                    "A* algorithm"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Write a function `find_minimum_spanning_tree` using Prim's algorithm that, given a connected, undirected graph represented as an adjacency list, returns the edges included in the minimum spanning tree of the graph. In your code comments, describe the time complexity of your implementation and how the approach would differ if you used Kruskal's algorithm.",
                "boilerplate": "def find_minimum_spanning_tree(adj_list):\n    # TODO: Implement the Prim's algorithm to find the minimum spanning tree\n    # Your function should return a list of edges that constitute the MST\n    # Also, comment on the time complexity of your implementation\n    pass",
                "test_cases_script": "# This script will contain test cases such as a simple triangle graph, a graph with a single node,\n# a complete graph, and a graph with multiple connected components.\n# Each test case should include assertions to validate the returned MST.",
                "concepts": [
                    "Minimum Spanning Trees",
                    "Prim's",
                    "Kruskal's Algorithm",
                    "time complexity",
                    "graph theory"
                ]
            }
        },
        {
            "subject": 1,
            "type": 0,
            "data": {
                "data": "Discuss the differences between Depth-First Search (DFS) and Breadth-First Search (BFS) in terms of their approach, application, and when one might be preferable over the other. Highlight how a 'stack' is utilized in DFS and a 'queue' in BFS.",
                "rubric": "Rubric: [1 Point] Description of DFS and BFS [2 Points] Correct explanation of 'stack' use in DFS and 'queue' use in BFS [2 Points] Comparison and contrast of application scenarios [1 Point] Discussion of time and space complexity considerations",
                "concepts": [
                    "Graph Traversal Algorithms",
                    "Depth-First Search (DFS)",
                    "Breadth-First Search (BFS)",
                    "stack",
                    "queue",
                    "time complexity",
                    "space complexity"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Implement the Depth-First Search algorithm to traverse a binary tree data structure using the provided `BinaryTreeNode` class. Ensure your solution is efficient and add comments to explain the space and time complexity of your implementation.",
                "boilerplate": "class BinaryTreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\ndef depth_first_search(root):\n    # TODO: Implement the DFS function to traverse the binary tree\n    # Your code here\n    pass\n\n\n# Example Usage:\n# root = BinaryTreeNode(1)\n# root.left = BinaryTreeNode(2)\n# root.right = BinaryTreeNode(3)\n# depth_first_search(root)\n",
                "test_cases_script": "def test_tree_traversal():\n    root = BinaryTreeNode(1)\n    root.left = BinaryTreeNode(2)\n    root.right = BinaryTreeNode(3)\n    assert depth_first_search(root) == [1, 2, 3], \"DFS does not traverse correctly\"\n\ntest_tree_traversal()\n",
                "concepts": [
                    "Graph Data Structure",
                    "Depth-First Search (DFS)",
                    "Space Complexity of Graph Data Structures",
                    "Trees and Special Graphs",
                    "Time Complexity of Graph Algorithms"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Write a function in Python that uses Prim's or Kruskal's Algorithm to find the Minimum Spanning Tree of a given undirected graph. The graph will be provided as an adjacency list, where each entry is a tuple (u, v, w) representing an edge from node u to node v with a weight w.",
                "boilerplate": "def find_MST(graph):\n    # Your code here\n    pass\n\n# graph is represented as a list of tuples (u, v, w)\n# Example: graph = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]",
                "test_cases_script": "# Using a simple assert statement to check for correctness.\n# The function should return a list of edges that constitute the MST.\nassert find_MST([(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]) == [(2, 3, 4), (0, 3, 5), (0, 1, 10)]",
                "concepts": [
                    "Trees and Special Graphs",
                    "Minimum Spanning Trees",
                    "Prim's",
                    "Kruskal's Algorithm",
                    "graph theory",
                    "data structures",
                    "algorithms"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Implement a function in Python that colors the vertices of a given graph using the Greedy Algorithm for graph coloring and returns the minimum number of colors needed, known as the graph's Chromatic Number. Assume the graph is represented as an adjacency list.",
                "boilerplate": "def greedy_coloring(graph):\n\t# Your code here\n\tpass",
                "test_cases_script": "graph1 = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}\ngraph2 = {0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 4], 3: [0], 4: [2]}\nassert greedy_coloring(graph1) == 3\nassert greedy_coloring(graph2) == 3  # Note: the greedy algorithm does not always find the optimal chromatic number",
                "concepts": [
                    "Graph Coloring and Scheduling",
                    "Chromatic Number",
                    "Greedy Algorithm"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Write a Python function that uses Graph Traversal to identify connected components in a network. The network is represented as a graph using an adjacency list. Additionally, explain in comments how the implemented Graph Traversal algorithm applies to a real-world scenario of your choice in Computer Science.",
                "boilerplate": "def find_connected_components(graph):\n\tpass\n\nnetwork = {}\nprint(find_connected_components(network))",
                "test_cases_script": "test_network_1 = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: [], 5: [6], 6: [5]}\nresult_1 = find_connected_components(test_network_1)\nassert result_1 == [[1, 2, 3], [4], [5, 6]], f'Error: {result_1}'\n\nnetwork = {1: [], 2: [], 3: [], 4: []}\nresult_2 = find_connected_components(network)\nassert result_2 == [[1], [2], [3], [4]], f'Error: {result_2}'",
                "concepts": [
                    "Practical Applications of Graph Theory",
                    "Computer Science",
                    "Graph Traversal Algorithms"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Implement Dijkstra's algorithm to find the shortest path in a graph represented as an adjacency list.",
                "boilerplate": "def dijkstra(graph, start):\n    pass # TODO: Implement Dijkstra's algorithm",
                "test_cases_script": "{\n    \"test_cases\": [\n        {\n            \"graph\": {\"A\": [(\"B\", 1), (\"C\", 4)], \"B\": [(\"C\", 1)], \"C\": []},\n            \"start\": \"A\",\n            \"end\": \"C\",\n            \"expected_output\": 2\n        },\n        {\n            \"graph\": {\"A\": [(\"B\", 5), (\"C\", 2)], \"B\": [(\"C\", 1)], \"C\": [(\"A\", 1)]},\n            \"start\": \"A\",\n            \"end\": \"C\",\n            \"expected_output\": 3\n        }\n    ]\n}",
                "concepts": [
                    "Dijkstra's",
                    "graph",
                    "time complexity",
                    "optimizations",
                    "adjacency list"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Implement both the DFS (using a stack) and BFS (using a queue) graph traversal algorithms to traverse a given graph from a specified starting node. You should output the nodes in the order they are visited for each algorithm and ensure your implementation is efficient in terms of time complexity.",
                "boilerplate": "from collections import deque\n\nclass Graph:\n\tdef __init__(self, num_nodes):\n\t\tself.num_nodes = num_nodes\n\t\tself.adj_list = [[] for _ in range(num_nodes)]\n\n\tdef add_edge(self, u, v):\n\t\tself.adj_list[u].append(v)\n\n\tdef dfs(self, start):\n\t\tvisited = [False] * self.num_nodes\n\t\tstack = [start]\n\t\ttraversal_order = []\n\n\t\twhile stack:\n\t\t\tnode = stack.pop()\n\t\t\tif not visited[node]:\n\t\t\t\ttraversal_order.append(node)\n\t\t\t\tvisited[node] = True\n\t\t\t\tfor neighbor in self.adj_list[node]:\n\t\t\t\t\tstack.append(neighbor)\n\t\treturn traversal_order\n\n\tdef bfs(self, start):\n\t\tvisited = [False] * self.num_nodes\n\t\tqueue = deque([start])\n\t\ttraversal_order = []\n\n\t\twhile queue:\n\t\t\tnode = queue.popleft()\n\t\t\tif not visited[node]:\n\t\t\t\ttraversal_order.append(node)\n\t\t\t\tvisited[node] = True\n\t\t\t\tfor neighbor in self.adj_list[node]:\n\t\t\t\t\tqueue.append(neighbor)\n\t\treturn traversal_order\n\n# Test the implementations\n",
                "test_cases_script": "g = Graph(6)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 3)\ng.add_edge(1, 4)\ng.add_edge(2, 5)\n\n# Test DFS\nassert g.dfs(0) == [0, 2, 5, 1, 4, 3]\n\n# Test BFS\nassert g.bfs(0) == [0, 1, 2, 3, 4, 5]",
                "concepts": [
                    "Graph Traversal Algorithms",
                    "Depth-First Search (DFS)",
                    "Breadth-First Search (BFS)",
                    "stack",
                    "queue",
                    "time complexity"
                ]
            }
        },
        {
            "subject": 1,
            "type": 3,
            "data": {
                "data": "Implement the Depth-First Search (DFS) algorithm and the Breadth-First Search (BFS) algorithm to search for a value in a binary search tree (BST). The BST is represented as an undirected graph with nodes labeled as unique integers. The BFS algorithm should return true if the value exists in the BST and false otherwise. The DFS algorithm should return true if the value exists in the BST and false otherwise.",
                "boilerplate": "def dfs(graph, start, target):\n    visit = []\n    stack = [start]\n\n    while len(stack) > 0:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visit:\n            visit.append(node)\n            stack.extend(graph[node])\n\n    return False\n\n\ndef bfs(graph, start, target):\n    visit = []\n    queue = [start]\n\n    while len(queue) > 0:\n        node = queue.pop(0)\n        if node == target:\n            return True\n        if node not in visit:\n            visit.append(node)\n            queue.extend(graph[node])\n\n    return False\n\ngraph = {0: [1, 2], 1: [3, 4], 2: [5, 6], 3: [], 4: [], 5: [], 6: []}  # Replace with appropriate edges\ntarget = 4\nprint(dfs(graph, 0, target))\nprint(bfs(graph, 0, target))",
                "test_cases_script": "",
                "concepts": [
                    "Graph Data Structure",
                    "Depth-First Search (DFS)",
                    "Breadth-First Search (BFS)",
                    "Graph Pathfinding Algorithms",
                    "trees",
                    "search trees"
                ]
            }
        }
    ],
    "current_obj_idx": 0,
    "num_questions": 12
}
